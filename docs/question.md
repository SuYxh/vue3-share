### vue2和vue3的响应式有什么区别？

**实现方式**

- Vue 2 使用的是 **Object.defineProperty** 方法来实现数据的响应式。这种方法只能劫持对象的属性，因此需要对每个属性进行遍历，如果属性值是对象，则需要递归遍历。
- Vue 3 则采用了 ES6 的 **Proxy** 作为响应式系统的底层实现。Proxy 可以直接监听对象和数组的变化，并且能监听到对象属性的添加和删除，从而使得响应式系统更加强大和灵活。

**性能**:

- Vue 2 的响应式系统由于需要递归遍历对象属性，可能会在处理大型对象时引起性能问题。
- Vue 3 的响应式系统使用 Proxy，避免了递归遍历的开销，因此在处理大型对象或数组时具有更好的性能表现。

**新特性支持**:

- Vue 3 的响应式系统支持更多的 JavaScript 数据类型，例如 Map、Set 等。
- Vue 3 还支持数组的响应式变化，可以直接监听数组的变化，而不是像 Vue 2 那样只能通过特定的方法（例如 `push`、`pop` 等）来实现响应式。



### **请解释 Vue 3 中 `reactive` 和 `ref` 的区别及用法。**

- `reactive` 用于创建一个响应式的对象，它接受一个普通对象并返回该对象的响应式代理。这个代理可以用来确保对象的所有属性都是响应式的。

- `ref` 用于创建一个响应式的引用，它接受一个基础类型（如字符串、数字等）或对象，并返回一个具有 `.value` 属性的响应式对象。`ref` 主要用于处理基础类型的响应式，但也可以用于对象。
- 使用场景：当你需要响应式地跟踪一个基本类型时使用 `ref`，当你需要使一个对象完全响应式时使用 `reactive`。



### **在 Vue 3 中，如何使用 `watchEffect` 函数？它与 `watch` 函数有什么区别？**

- `watchEffect` 会立即执行传入的回调函数，并在回调函数中访问的任何响应式数据发生变化时再次执行。
- 与 `watch` 不同，`watchEffect` 不需要明确指定依赖项，它会自动追踪回调函数中使用的响应式数据。
- 使用场景：当你需要自动追踪回调函数中使用的所有响应式数据时使用 `watchEffect`。



### **`toRefs` 和 `toRef` 的作用：**

- `toRefs` 可以将一个响应式对象的所有属性转换为响应式引用（`ref`），这在解构响应式对象时非常有用，因为解构后的属性会失去响应性。
- `toRef` 可以将一个响应式对象的单个属性转换为响应式引用。
- 使用场景：在需要保持解构后属性的响应性时使用 `toRefs`，在需要将对象的单个属性转换为响应式引用时使用 `toRef`。



